from __future__ import annotations

from datetime import datetime
from typing import List, Optional

from sqlalchemy.orm import Session

from app.models import League, Team, TransactionLog
from app.api.schemas import TeamUpdate


class TeamService:
    """Service layer for team management business logic."""

    # ---------------------------------------------------------------------
    # Retrieval helpers
    # ---------------------------------------------------------------------

    @staticmethod
    def get_team_by_id(db: Session, team_id: int) -> Optional[Team]:
        """Return a single team by primary key or ``None`` if not found."""
        return db.query(Team).filter(Team.id == team_id).one_or_none()

    @staticmethod
    def get_teams_by_owner_id(db: Session, owner_id: int) -> List[Team]:
        """Return all teams for a given owner (user)."""
        return list(db.query(Team).filter(Team.owner_id == owner_id).all())

    @staticmethod
    def get_teams_by_league_id(db: Session, league_id: int) -> List[Team]:
        """Return all teams in a league."""
        return list(db.query(Team).filter(Team.league_id == league_id).all())

    # ------------------------------------------------------------------
    # Mutations
    # ------------------------------------------------------------------

    @staticmethod
    def _check_name_unique(db: Session, league_id: int, name: str, exclude_team_id: Optional[int] = None) -> None:
        """Raise ``ValueError`` if *name* already exists in the league (case-insensitive)."""
        query = db.query(Team).filter(Team.league_id == league_id, Team.name.ilike(name))
        if exclude_team_id is not None:
            query = query.filter(Team.id != exclude_team_id)

        exists = query.first() is not None
        if exists:
            raise ValueError("Team name already exists in this league")

    # ------------------------------------------------------------------
    @classmethod
    def create_team_in_league(cls, db: Session, name: str, league_id: int, owner_id: int) -> Team:
        """Create a new team in *league_id* owned by *owner_id* with *name*.

        Performs business rule checks:
        * League must exist
        * Owner cannot already have a team in the league (MVP rule)
        * Team name must be unique within the league (case-insensitive)
        * Creates a TransactionLog entry on success
        """
        # League existence
        league = db.query(League).filter(League.id == league_id).one_or_none()
        if league is None:
            raise ValueError("League not found")

        # One team per user per league
        already_has_team = (
            db.query(Team).filter(Team.league_id == league_id, Team.owner_id == owner_id).count() > 0
        )
        if already_has_team:
            raise ValueError("User already owns a team in this league")

        # Name uniqueness (case-insensitive)
        cls._check_name_unique(db, league_id, name)

        # Create team
        team = Team(name=name, league_id=league_id, owner_id=owner_id)
        db.add(team)
        db.flush()  # Get autogenerated PK before logging

        # Transaction log
        db.add(
            TransactionLog(
                user_id=owner_id,
                action=f"CREATE TEAM '{name}' in league {league_id}",
                timestamp=datetime.utcnow(),
            )
        )

        db.commit()
        db.refresh(team)
        return team

    # ------------------------------------------------------------------
    @classmethod
    def update_team_details(cls, db: Session, team_id: int, owner_id: int, data: TeamUpdate) -> Optional[Team]:
        """Update an existing team. Only owner can update. Returns updated team or ``None`` if not found."""
        team = db.query(Team).filter(Team.id == team_id).one_or_none()
        if team is None:
            return None

        if team.owner_id != owner_id:
            # Not authorized
            raise PermissionError("Not team owner")

        updated = False

        if data.name is not None and data.name != team.name:
            # Name uniqueness check within league
            cls._check_name_unique(db, team.league_id, data.name, exclude_team_id=team_id)
            team.name = data.name
            updated = True

        if updated:
            db.add(
                TransactionLog(
                    user_id=owner_id,
                    action=f"UPDATE TEAM {team_id} – details changed",  # keep simple for now
                    timestamp=datetime.utcnow(),
                )
            )
            db.commit()
            db.refresh(team)
        return team


# ---------------------------------------------------------------------------
# Helper – convert ORM -> TeamOut
# ---------------------------------------------------------------------------

from app.api.schemas import PlayerOut, TeamOut  # noqa: E402 – avoid circular until after class definition


def map_team_to_out(team: Team) -> TeamOut:  # noqa: D401
    """Populate a TeamOut DTO from ORM *team* instance, including roster and season points."""
    # Build roster list
    roster_players = [PlayerOut.from_orm(rs.player) for rs in team.roster_slots]

    season_points = sum(score.score for score in team.scores)

    return TeamOut(
        id=team.id,
        name=team.name,
        league_id=team.league_id,
        owner_id=team.owner_id,
        moves_this_week=team.moves_this_week,
        roster=roster_players,
        season_points=round(season_points, 2),
    )